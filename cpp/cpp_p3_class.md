# 类设计者工具

## 面向对象程序设计

- 基类与派生类（继承）

  ```cpp
  class Person{
      //私有修饰符仅可在该类中访问，而保护修饰符可在基类和派生类中访问。
      protected:
      	string name;
  };
  
  //class ClassB:public ClassA{};
  //类B继承类A，类A为基类，类B为类A的派生类。
  class Teacher:public Person{
      public:
      	string GetName() const {return this->name;}
  	protected:
          string Subject;
  };
  ```

- 成员函数的继承

  覆盖/非覆盖

  ```cpp
  //覆盖基类定义的函数，使派生类拥有自己的版本。
  //虚函数
  class Base{
      public:
      	virtual void Func1(){cout<<"virtual func"<<endl;}	//非虚函数，可以进行动态绑定。
      	virtual void Func2()=0;								//纯虚函数，派生类中必须进行定义。
      	void Func3(){cout<<"func"<<endl;}					//静态链接的函数，派生类中重载无效。
  };
  
  ```

  

## 运算符重载、类型转换

### 函数调用运算符

operator()，像函数一样使用该类的对象。类可以储存状态，故比普通函数更加灵活。

- 函数对象

  定义了调用运算符的对象即为函数对象。
  
  ```cpp
  struct absInt{
      int operator() (int val) const{
          return val<0?-val:val;
      }
  };
  int main(void)
  {
      absInt absObj;
      cout<<absObj(-114514)<<endl;
      return 0;
  }
  ```



# 拷贝控制

拷贝、移动、赋值、销毁。

## 五种特殊成员函数

| 拷贝           | 移动           | 销毁     |
| -------------- | -------------- | -------- |
| 拷贝构造函数   | 移动构造函数   | 析构函数 |
| 拷贝赋值运算符 | 移动赋值运算符 |          |

- 赋值运算符不属于构造函数，带参数。

## 拷贝构造函数

某一构造函数（无返回值）的第一个参数是自身类类型的引用（可以且一般是const的），且任何额外参数都有默认值，则该构造函数即为拷贝构造函数。

拷贝构造函数*不应该*是explicit的。

```cpp
class Foo {
public:
    Foo();
    Foo(const Foo &);	// 拷贝构造函数
};
```



### 合成的拷贝构造函数

类中没有定义拷贝构造函数时，编译器会定义一个合成的拷贝构造函数，即使已经存在其他构造函数（只有默认构造函数是当存在其他构造函数时不会合成）。

一般情况，该函数的行为是将对象中的成员逐个拷贝（调用成员类的拷贝构造函数）到创建中的对象。

- 例类

  ```cpp
  class Person {
  public:
      Person(const Person &);
  private:
      int age;
      string name;
  };
  ```
  
- 合成拷贝构造函数的等价行为

  ```cpp
  Person::Person(const Person &p)
      : age(p.age), name(p.name) {}	// 此处均为拷贝，调用了int和string的拷贝构造函数。
  ```



### 拷贝初始化

使用等号（=）或其他会调用拷贝构造函数（不包括直接初始化部分）初始化的对象。不使用等号则为直接初始化。

- 拷贝初始化与直接初始化

  ```cpp
  string dots(10, '.');			// 直接初始化
  string s(dots);					// 直接初始化，执行拷贝构造函数
  string s2 = dots;				// 拷贝初始化，拷贝赋值运算符（编译器可能会优化为直接初始化）
  string s3 = "114514";			// 拷贝初始化，
  string nines = string(100, '9');// 拷贝初始化，拷贝赋值运算符（编译器可能会优化为直接初始化）
  ```

- 其他会发生拷贝初始化的情况

  - **值语义传参，或以值语义返回对象时**

    ```cpp
    // 调用两次拷贝构造函数
    Person f(Person p) {
        return p;
    }
    ```

  - 使用初始化列表初始化一个数组中的元素，或初始化一个聚合类的成员时

- 容器的emplace方法是直接初始化，push方法是拷贝初始化

### 参数和返回值

非引用类型的参数要进行拷贝初始化，类似的，非引用类型的返回值也要进行拷贝初始化。

鉴于上述特性，拷贝构造函数的参数必须是引用类型。如果拷贝构造函数的参数为值类型，则在给拷贝构造函数传参时也需要调用拷贝构造函数，如此无限循环。

## 拷贝赋值运算符

拷贝赋值运算符接受与其所在类的相同类类型参数（值、引用均可）。

```cpp
class Foo {
public:
    Foo &operator=(const Foo &);
};
```

为了与内置类型的赋值行为保持一致，其返回值通常为该类型的引用。

### 合成的拷贝赋值运算符

一个类未定义自己的拷贝赋值运算符时，编译器会为该类生成一个**合成的拷贝赋值运算符**。

- 合成拷贝赋值运算符的等价行为

  ```cpp
  Person& Person::operator=(const Person &rhs/* 右侧引用 */)
  {
      age = rhs.age;
      name = rhs.name;
      return *this;
  }
  ```



## 析构函数

构造函数初始化对象的非static数据成员；析构函数负责释放对象使用的资源，销毁对象的非static成员。

```cpp
class Foo {
public:
    ~Foo();
};
```

- 析构函数无返回值，不接受参数

- 析构函数有一个函数体，有一个析构部分（析构部分是隐式的）

  首先执行函数体（此时仍可访问成员），然后销毁成员，成员按初始化顺序逆序销毁（执行类成员的析构函数）。

- 内置类型没有析构函数

### 析构函数调用的时机

对象被销毁时，都会自动调用其析构函数。

- 变量离开其作用域时（变量作用域等同于变量生命期）
- 对象销毁时，其成员被销毁时
- 数组被销毁时，其元素被销毁



